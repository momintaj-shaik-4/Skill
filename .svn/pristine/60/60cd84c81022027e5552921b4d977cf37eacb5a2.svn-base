from typing import Optional, List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.models import User
from sqlalchemy import Table, MetaData

from app.db.session import engine

metadata = MetaData()
async def get_manager_employee_table():
    async with engine.begin() as conn:
        # Reflect table inside run_sync
        await conn.run_sync(metadata.reflect, only=["manager_employee"])
    # Now metadata is loaded, return Table object
    return Table("manager_employee", metadata, autoload_with=None) # Assuming it's loaded elsewhere


async def get_user_by_username(db: AsyncSession, username: str | int) -> Optional[User]:
    stmt = select(User).where(User.username == str(username))
    result = await db.execute(stmt)
    return result.scalar_one_or_none()


async def create_user(db: AsyncSession, username: str | int, password: str) -> User:
    from app.core.security import get_password_hash
    hashed_pw = get_password_hash(password)
    user = User(username=str(username), hashed_password=hashed_pw)
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return user


async def authenticate_user(db: AsyncSession, username: str | int, password: str) -> bool:
    from app.core.security import verify_password
    user = await get_user_by_username(db, username)
    if not user:
        return False
    return verify_password(password, user.hashed_password)


async def get_direct_reports(db: AsyncSession, manager_empid: str | int) -> List[str]:
    ManagerEmployee = await get_manager_employee_table()
    stmt = select(ManagerEmployee.c.employee_empid).where(ManagerEmployee.c.manager_empid == str(manager_empid))
    result = await db.execute(stmt)
    rows = result.scalars().all()
    return rows


async def get_manager_name_for_emp(db: AsyncSession, empid: str | int) -> Optional[str]:
    ManagerEmployee = await get_manager_employee_table()
    stmt = select(ManagerEmployee.c.manager_name).where(ManagerEmployee.c.employee_empid == str(empid))
    result = await db.execute(stmt)
    row = result.scalar_one_or_none()
    return row


async def get_employee_name(db: AsyncSession, empid: str | int) -> Optional[str]:
    ManagerEmployee = await get_manager_employee_table()
    stmt = select(ManagerEmployee.c.employee_name).where(ManagerEmployee.c.employee_empid == str(empid))
    result = await db.execute(stmt)
    row = result.scalar_one_or_none()
    return row
